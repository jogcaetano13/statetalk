package com.kmpbits.communication_core.request

import com.kmpbits.communication_core.alias.Body
import com.kmpbits.communication_core.alias.Header
import com.kmpbits.communication_core.alias.Headers
import com.kmpbits.communication_core.alias.Parameter
import com.kmpbits.communication_core.alias.Parameters
import com.kmpbits.communication_core.annotations.CommunicationMarker
import com.kmpbits.communication_core.client.interceptors.CustomHeaderInterceptor
import com.kmpbits.communication_core.enums.HttpHeader
import com.kmpbits.communication_core.enums.HttpMethod
import com.kmpbits.communication_core.exceptions.CommunicationException
import com.kmpbits.communication_core.extensions.toJson
import com.kmpbits.communication_core.extensions.toName
import com.kmpbits.communication_core.extensions.urlWithPath
import okhttp3.MediaType.Companion.toMediaType
import okhttp3.MultipartBody
import okhttp3.OkHttpClient
import okhttp3.Request
import okhttp3.RequestBody
import okhttp3.RequestBody.Companion.toRequestBody
import java.io.File
import java.util.Date

@CommunicationMarker
class RequestBuilder internal constructor(
    private val client: OkHttpClient,
    private val baseUrl: String
) {

    @PublishedApi
    internal var preCall: (() -> Unit)? = null

    internal val parameters: Parameters = mutableListOf()
    internal val headers: Headers = mutableListOf()

    private var body: RequestBody? = null

    /**
     * The method of the request.
     * @see [HttpMethod]
     */
    var method: HttpMethod = HttpMethod.Get

    /**
     * The partial url of this particular request.
     * It will be joined into base url.
     */
    var path: String = ""

    /**
     * The method to parse a string date into a [Date class].
     * This is used if you have a [Date] class as a class parameter
     */
    var dateFormat: String = "yyyy-MM-dd'T'HH:mm:ss.ZZZZZZZ"

    /**
     * Call this method if you want to do something before the request starts
     *
     */
    fun preCall(call: () -> Unit) {
        this.preCall = call
    }

    fun updateParameter(key: String, value: Any): Parameter {
        val existParameter = parameterByKey(key)

        if (existParameter == null)
            parameters.add(Parameter(key, value))

        val newParameter = Parameter(key, value)

        existParameter?.let {
            parameters.remove(it)
            parameters.add(newParameter)
        }

        return newParameter
    }

    /**
     * The [Header] object to send in the http request in this particular request.
     *
     * @param header The header to send.
     */
    fun header(header: Header) {
        if (headers.contains(header).not())
            headers.add(header)
    }

    /**
     * Authorization header to to send in the http request for this particular request.
     *
     * @param token The token generated by the api server.
     * @param prefix That is used to the header. Default is 'Bearer'.
     */
    fun authorization(token: String?, prefix: String = "Bearer") {
        if (hasHeader(HttpHeader.AUTHORIZATION).not()) {
            val header = Header(HttpHeader.AUTHORIZATION, "$prefix $token")
            headers.add(header)
        }
    }

    /**
     * The language that will be used in the server to get the response for this particular request.
     *
     * @param languageCode Should have 2 characters only.
     * If you already sent the language, this will be ignored.
     */
    fun language(languageCode: String) {
        if (languageCode.length > 2 || languageCode.length < 2)
            throw CommunicationException("Language code must contains only 2 characters")

        if (hasHeader(HttpHeader.ACCEPT_LANGUAGE).not()) {
            val header = Header(HttpHeader.ACCEPT_LANGUAGE, languageCode)
            headers.add(header)
        }
    }

    /**
     * The query parameter of the request.
     *
     * If you already sent the same parameter, this will be ignored.
     *
     * @param parameter Key-value parameter to send
     */
    fun parameter(parameter: Parameter) {
        if (parameters.contains(parameter).not())
            parameters.add(parameter)
    }

    /**
     * The query parameter of the request.
     * This functions allows to send a value in a [List]
     *
     * If you already sent the same parameter [key], this will be ignored.
     *
     * @param key
     * @param value
     */
    fun parameter(key: String, value: List<Any>) {
        value.forEach {
            val parameter = Parameter(key, it)
            parameter(parameter)
        }
    }

    /**
     * The body parameter of the request.
     * This should be used only with [HttpMethod.POST]
     *
     * @param body the key-value map.
     */
    fun body(body: Body) {
        this.body = body.toJson(dateFormat).toRequestBody("application/json; charset=utf-8".toMediaType())
    }

    /**
     * The body parameter of the request.
     * This should be used only with [HttpMethod.POST]
     *
     * The [body] will be converted into json string.
     *
     * @param body the object of type [T] to send
     */
    fun <T : Any> body(body: T) {
        this.body = body.toJson(dateFormat).toRequestBody("application/json; charset=utf-8".toMediaType())
    }

    /**
     * The body parameter of the request.
     * This should be used only with [HttpMethod.POST]
     *
     * @param body the object of type [RequestBody] to send
     */
    fun body(body: RequestBody) {
        this.body = body
    }

    /**
     * This is used to create a new multipart request body
     *
     * @param block lambda receiver to create a new request body with multipart
     */
    fun body(block: MultipartBody.Builder.() -> Unit) {
        this.body = MultipartBody.Builder().also(block).build()
    }

    /**
     * Upload file body with progress
     *
     * @param fieldName The name of the backend field
     * @param file The file to upload
     * @param contentType The content type of the body
     * @param onProgress Lambda to track the progress of the upload
     */
    fun uploadFileBody(
        fieldName: String,
        file: File,
        contentType: String = "text/plain",
        onProgress: (Long) -> Unit = {}
    ) {
        body {
            setType(MultipartBody.FORM)
            addFormDataPart(fieldName, file.name, UploadFileRequestBody(file, contentType, onProgress))
        }
    }

    internal fun build(): Request.Builder {
        val requestBuilder = Request.Builder()
            .url(
                urlWithPath(
                baseUrl,
                path,
                method,
                parameters
            ))

        headers.forEach {
            requestBuilder.addHeader(it.first.header, it.second)
        }

        val headerInterceptor = client.interceptors.find { it is CustomHeaderInterceptor }

        (headerInterceptor as? CustomHeaderInterceptor)?.let {
            it.getHeaders().forEach {
                requestBuilder.addHeader(it.first.header, it.second)
            }
        }

        val method = method.toName()

        if (okhttp3.internal.http.HttpMethod.requiresRequestBody(method) && body == null) {
            body = if (parameters.isEmpty())
                "".toRequestBody()
            else
                parameters.toJson(dateFormat).toRequestBody("application/json; charset=utf-8".toMediaType())
        }

        requestBuilder.method(method, body)
        return requestBuilder
    }

    private fun parameterByKey(key: String) = parameters.find { it.first == key }

    private fun hasHeader(key: HttpHeader) = headers.find { it.first == key } != null
}